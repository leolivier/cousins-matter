{% extends "genealogy/base_genealogy.html" %}
{% load i18n %}
{% load static %}

{% block genealogy_content %}
<div class="box" style="height: 80vh; overflow: hidden; position: relative;">
    <div id="tree-container" style="width: 100%; height: 100%;"></div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>
<script>
    const container = document.getElementById('tree-container');
    const width = container.clientWidth;
    const height = container.clientHeight;

    const svg = d3.select("#tree-container").append("svg")
        .attr("width", width)
        .attr("height", height)
        .call(d3.zoom().on("zoom", (event) => {
            g.attr("transform", event.transform);
        }))
        .append("g");

    const g = svg.append("g");

    d3.json("{% url 'genealogy:tree_data' %}").then(data => {
        // Create a new directed graph
        const graph = new dagre.graphlib.Graph();
        graph.setGraph({
            rankdir: 'TB',
            nodesep: 50,
            ranksep: 100,
            marginx: 20,
            marginy: 20
        });
        graph.setDefaultEdgeLabel(() => ({}));

        // Add nodes
        data.people.forEach(person => {
            // Calculate width based on name length
            const nameWidth = person.name.length * 10; // Approx 10px per char
            const width = Math.max(200, nameWidth + 80); // Min 200px, +80 for avatar/padding
            const height = 100;

            graph.setNode(person.id, {
                label: person.name,
                width: width,
                height: height,
                data: person,
                type: 'person'
            });
        });

        // Add family nodes and edges
        data.families.forEach(family => {
            // Family node (invisible junction)
            graph.setNode(family.id, {
                label: '',
                width: 1,
                height: 1,
                type: 'family',
                data: family
            });

            // Edges from partners to family
            graph.setEdge(family.partner1_id, family.id, { type: 'partner' });
            graph.setEdge(family.partner2_id, family.id, { type: 'partner' });

            // Edges from family to children
            family.children_ids.forEach(childId => {
                graph.setEdge(family.id, childId, { type: 'child' });
            });
        });

        // Compute the layout
        dagre.layout(graph);

        // Render edges
        const edges = g.append("g")
            .attr("class", "edges")
            .selectAll("path")
            .data(graph.edges())
            .enter().append("g");

        edges.append("path")
            .attr("d", e => {
                const v = graph.node(e.v);
                const w = graph.node(e.w);
                const points = graph.edge(e).points;

                // Custom orthogonal path
                // Start
                let path = `M ${v.x} ${v.y + v.height / 2}`; // Bottom center of source (or center)

                // For partner links (Person -> Family), we want them to go down then horizontal
                // For child links (Family -> Person), we want them to go down then horizontal

                // Dagre gives us points. Let's try to use them but orthogonalize
                // Or just use simple Manhattan routing since we know the structure

                // Simple approach:
                // Start at bottom center of source
                // End at top center of target

                const startX = v.x;
                const startY = v.y + v.height / 2;
                const endX = w.x;
                const endY = w.y - w.height / 2;

                const midY = (startY + endY) / 2;

                return `M ${startX} ${startY} V ${midY} H ${endX} V ${endY}`;
            })
            .attr("stroke", "#999")
            .attr("stroke-width", 2)
            .attr("fill", "none");

        // Render union dates on family nodes
        g.append("g")
            .attr("class", "family-labels")
            .selectAll("text")
            .data(data.families)
            .enter().append("text")
            .attr("x", d => {
                const node = graph.node(d.id);
                return node ? node.x : 0;
            })
            .attr("y", d => {
                const node = graph.node(d.id);
                return node ? node.y - 10 : 0; // Slightly above the junction
            })
            .attr("text-anchor", "middle")
            .style("font-size", "10px")
            .style("fill", "#555")
            .style("background-color", "white") // Optional: add background rect for readability
            .text(d => {
                if (d.union_date) {
                    let text = d.union_date;
                    if (d.separation_date) text += " - " + d.separation_date;
                    return text;
                }
                return "";
            });

        // Render nodes
        const nodes = g.append("g")
            .attr("class", "nodes")
            .selectAll("foreignObject")
            .data(graph.nodes().filter(id => graph.node(id).type === 'person'))
            .enter().append("foreignObject")
            .attr("width", id => graph.node(id).width)
            .attr("height", id => graph.node(id).height)
            .attr("x", id => graph.node(id).x - graph.node(id).width / 2)
            .attr("y", id => graph.node(id).y - graph.node(id).height / 2)
            .on("click", (event, id) => {
                const d = graph.node(id).data;
                window.location.href = d.url;
            });

        nodes.append("xhtml:div")
            .style("width", "100%")
            .style("height", "100%")
            .style("border", "1px solid #ccc")
            .style("border-radius", "5px")
            .style("background-color", "white")
            .style("display", "flex")
            .style("align-items", "center")
            .style("padding", "5px")
            .style("box-shadow", "2px 2px 5px rgba(0,0,0,0.1)")
            .style("cursor", "pointer")
            .html(id => {
                const d = graph.node(id).data;
                return `
                <div style="margin-right: 10px;">
                    ${d.avatar_url ? `<img src="${d.avatar_url}" style="width: 50px; height: 50px; border-radius: 50%; object-fit: cover;">` : '<span class="icon is-large"><i class="mdi mdi-account mdi-48px"></i></span>'}
                </div>
                <div style="flex-grow: 1; overflow: hidden;">
                    <div style="font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${d.name}</div>
                    <div style="font-size: 0.8em;">
                        ${d.birth_date} ${d.death_date ? '- ' + d.death_date : ''}
                    </div>
                    <div>
                        <span class="icon is-small">
                            <i class="mdi mdi-${d.gender_icon}"></i>
                        </span>
                    </div>
                </div>
            `});

        // Center the graph
        const graphWidth = graph.graph().width;
        const graphHeight = graph.graph().height;
        const zoomScale = Math.min(width / graphWidth, height / graphHeight) * 0.9;
        const zoomX = (width - graphWidth * zoomScale) / 2;
        const zoomY = (height - graphHeight * zoomScale) / 2;

        svg.call(d3.zoom().transform, d3.zoomIdentity.translate(zoomX, zoomY).scale(zoomScale));
    });
</script>
{% endblock %}
