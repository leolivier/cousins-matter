{% extends "genealogy/base_genealogy.html" %}
{% load i18n static cache %}

{% block genealogy_content %}
{% cache 300 genealogy_family_tree_v5 %}
<style>
    .edge-path {
        transition: stroke 0.2s, stroke-width 0.2s;
        cursor: pointer;
        stroke-opacity: 0.6; /* Default opacity */
    }
    .edge-path:hover {
        /* Optional: keep single hover selection or remove it if user strictly wants group behavior.
           User request implies group visibility is key.
           Let's keep hover for single line guide, but 'selected' is for the group. */
        stroke: #3273dc;
        stroke-width: 3px;
        z-index: 100;
    }
    .edge-path.selected {
        stroke: #f14668 !important; /* Bulma danger red */
        stroke-width: 4px !important;
        stroke-opacity: 1 !important;
    }
</style>
<div class="box" style="height: 80vh; overflow: hidden; position: relative;">
    <div id="tree-container" style="width: 100%; height: 100%;"></div>
</div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>
<script>
    const container = document.getElementById('tree-container');
    const width = container.clientWidth;
    const height = container.clientHeight;

    const svg = d3.select("#tree-container").append("svg")
        .attr("width", width)
        .attr("height", height)
        .call(d3.zoom().on("zoom", (event) => {
            g.attr("transform", event.transform);
        }))
        .append("g");

    const g = svg.append("g");

    d3.json("{% url 'genealogy:tree_data' %}").then(data => {
        // Create a new directed graph
        const graph = new dagre.graphlib.Graph();
        graph.setGraph({
            rankdir: 'TB',
            nodesep: 50,
            ranksep: 200,
            marginx: 20,
            marginy: 20
        });
        graph.setDefaultEdgeLabel(() => ({}));

        // Add nodes
        data.people.forEach(person => {
            // Calculate width based on name length
            const nameWidth = person.name.length * 10; // Approx 10px per char
            const width = Math.max(200, nameWidth + 80); // Min 200px, +80 for avatar/padding
            const height = 100;

            graph.setNode(person.id, {
                label: person.name,
                width: width,
                height: height,
                data: person,
                type: 'person'
            });
        });

        // Add family nodes and edges
        data.families.forEach(family => {
            // Family node (invisible junction)
            graph.setNode(family.id, {
                label: '',
                width: 1,
                height: 1,
                type: 'family',
                data: family
            });

            // Edges from partners to family
            // high weight to keep partners close to the family center
            graph.setEdge(family.partner1_id, family.id, { type: 'partner', weight: 10 });
            graph.setEdge(family.partner2_id, family.id, { type: 'partner', weight: 10 });

            // Edges from family to children
            family.children_ids.forEach(childId => {
                graph.setEdge(family.id, childId, { type: 'child', weight: 1 });
            });
        });

        // Compute the layout
        dagre.layout(graph);

        // Render edges
        const edges = g.append("g")
            .attr("class", "edges")
            .selectAll("path")
            .data(graph.edges())
            .enter().append("g");

        edges.append("path")
            .attr("class", "edge-path")
            .attr("d", e => {
                const v = graph.node(e.v);
                const w = graph.node(e.w);
                const points = graph.edge(e).points;

                // Custom orthogonal path
                // Start
                let path = `M ${v.x} ${v.y + v.height / 2}`; // Bottom center of source (or center)

                // For partner links (Person -> Family), we want them to go down then horizontal
                // For child links (Family -> Person), we want them to go down then horizontal

                // Dagre gives us points. Let's try to use them but orthogonalize
                // Or just use simple Manhattan routing since we know the structure

                // Simple approach:
                // Start at bottom center of source
                // End at top center of target

                const startX = v.x;
                const startY = v.y + v.height / 2;
                const endX = w.x;
                const endY = w.y - w.height / 2;

                // Calculate a basic midY
                let midY = (startY + endY) / 2;

                // Add an offset based on the Family ID to separate lines for different families
                // The edge could be Partner->Family (target is family) or Family->Child (source is family)
                let familyId = null;
                if (graph.node(e.w).type === 'family') {
                    familyId = e.w;
                } else if (graph.node(e.v).type === 'family') {
                    familyId = e.v;
                }

                if (familyId) {
                    // Simple hash function for the ID string (e.g. "f123")
                    let hash = 0;
                    for (let i = 0; i < familyId.length; i++) {
                        hash = (hash << 5) - hash + familyId.charCodeAt(i);
                        hash |= 0;
                    }
                    // Offset between -40 and +40 (range 80)
                    // Use a prime number for modulo to reduce collisions
                    const offset = (Math.abs(hash) % 79) - 39;
                    midY += offset;
                }

                return `M ${startX} ${startY} V ${midY} H ${endX} V ${endY}`;
            })
            .attr("stroke", "#999")
            .attr("stroke-width", 2)
            .attr("fill", "none")
            .attr("data-family-id", e => {
                const graph = new dagre.graphlib.Graph(); // We don't have access to graph scope here directly if we don't be careful?
                // Wait, 'graph' is available in the scope above.
                // We need to re-derive familyId or store it.
                // Let's copy the logic or better yet, calculate it once.

                // Oops, the previous block was calculating it inside the 'd' attribute function.
                // D3 'attr' takes a function.

                // Let's refactor the attribute setting to be cleaner or duplicate the logic safely.
                // Since I can't easily refactor the whole block with replace_file_content safely without context,
                // I will duplicate the lightweight check.

                // Actually, I can just not set it here and set it in a .each() or just rely on the fact that I am replacing the .attr chain.
                // But replace_file_content works on chunks.

                // I'll rewrite the whole edges.append("path") chain to be safe and clean.
                // But I should be careful about the previous chunk replacement.
                return null;
            });

        // Re-selecting to apply logic cleanly
        edges.selectAll("path")
            .attr("data-family-id", e => {
                 let familyId = null;
                if (graph.node(e.w).type === 'family') {
                    familyId = e.w;
                } else if (graph.node(e.v).type === 'family') {
                    familyId = e.v;
                }
                return familyId;
            })
            .on("mousedown", function(event, d) {
                const familyId = d3.select(this).attr("data-family-id");
                if (familyId) {
                    d3.selectAll(`.edge-path[data-family-id="${familyId}"]`).classed("selected", true);
                }
                event.stopPropagation();
            })
            .on("mouseup", function(event, d) {
                d3.selectAll(".edge-path").classed("selected", false);
                event.stopPropagation();
            })
            .on("mouseleave", function(event, d) {
                // Also clear if mouse leaves the element while pressing?
                // Or maybe global mouseup?
                // User said "during the time where the mouse button is down".
                // Usually implying a press-hold.
                // A simple mouseup on the element is good, but if they drag out it might stick.
                // Let's attach a global mouseup listener to body once?
                // For simplicity, let's stick to local mouseup/mouseleave for now as it's cleaner.
                d3.selectAll(".edge-path").classed("selected", false);
            })
            // Support touch for mobile
            .on("touchstart", function(event, d) {
                 const familyId = d3.select(this).attr("data-family-id");
                if (familyId) {
                    d3.selectAll(`.edge-path[data-family-id="${familyId}"]`).classed("selected", true);
                }
                event.stopPropagation();
            })
            .on("touchend", function(event, d) {
               d3.selectAll(".edge-path").classed("selected", false);
               event.stopPropagation();
            });

        // Render union dates on family nodes
        g.append("g")
            .attr("class", "family-labels")
            .selectAll("text")
            .data(data.families)
            .enter().append("text")
            .attr("x", d => {
                const node = graph.node(d.id);
                return node ? node.x : 0;
            })
            .attr("y", d => {
                const node = graph.node(d.id);
                return node ? node.y - 10 : 0; // Slightly above the junction
            })
            .attr("text-anchor", "middle")
            .style("font-size", "10px")
            .style("fill", "#555")
            .style("background-color", "white") // Optional: add background rect for readability
            .text(d => {
                if (d.union_date) {
                    let text = d.union_date;
                    if (d.separation_date) text += " - " + d.separation_date;
                    return text;
                }
                return "";
            });

        // Render nodes
        const nodes = g.append("g")
            .attr("class", "nodes")
            .selectAll("foreignObject")
            .data(graph.nodes().filter(id => graph.node(id).type === 'person'))
            .enter().append("foreignObject")
            .attr("width", id => graph.node(id).width)
            .attr("height", id => graph.node(id).height)
            .attr("x", id => graph.node(id).x - graph.node(id).width / 2)
            .attr("y", id => graph.node(id).y - graph.node(id).height / 2)
            .on("click", (event, id) => {
                const d = graph.node(id).data;
                window.location.href = d.url;
            });

        nodes.append("xhtml:div")
            .style("width", "100%")
            .style("height", "100%")
            .style("border", "1px solid #ccc")
            .style("border-radius", "5px")
            .style("background-color", "white")
            .style("display", "flex")
            .style("align-items", "center")
            .style("padding", "5px")
            .style("box-shadow", "2px 2px 5px rgba(0,0,0,0.1)")
            .style("cursor", "pointer")
            .html(id => {
                const d = graph.node(id).data;
                return `
                <div style="margin-right: 10px;">
                    ${d.avatar_url ? `<img src="${d.avatar_url}" style="width: 50px; height: 50px; border-radius: 50%; object-fit: cover;">` : '<span class="icon is-large"><i class="mdi mdi-account mdi-48px"></i></span>'}
                </div>
                <div style="flex-grow: 1; overflow: hidden;">
                    <div style="font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${d.name}</div>
                    <div style="font-size: 0.8em;">
                        ${d.birth_date} ${d.death_date ? '- ' + d.death_date : ''}
                    </div>
                    <div>
                        <span class="icon is-small">
                            <i class="mdi mdi-${d.gender_icon}"></i>
                        </span>
                    </div>
                </div>
            `});

        // Center the graph
        const graphWidth = graph.graph().width;
        const graphHeight = graph.graph().height;
        const zoomScale = Math.min(width / graphWidth, height / graphHeight) * 0.9;
        const zoomX = (width - graphWidth * zoomScale) / 2;
        const zoomY = (height - graphHeight * zoomScale) / 2;

        svg.call(d3.zoom().transform, d3.zoomIdentity.translate(zoomX, zoomY).scale(zoomScale));
    });
</script>
{% endcache %}
{% endblock %}
